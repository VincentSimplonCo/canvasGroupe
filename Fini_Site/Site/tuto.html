<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Tutoriel Canvas</title>
  <link rel="stylesheet" href="tuto.css" type="text/css" />
  <link href='https://fonts.googleapis.com/css?family=Montserrat:400,700|Raleway:400,900,300' rel='stylesheet' type='text/css'>
</head>
<body>
  <header>
    <ul id="navbar">
      <li id="EnCours">TUTORIEL</li>
      <li onmouseover="info(2)"><a href="testeur.html">TESTEUR</a></li>
      <li onmouseover="info(3)"><a href="atelier.html">ATELIER</a></li>
      <li onmouseover="info(4)"><a href="#">BLABLA</a></li>
      <li onmouseover="info(5)"><a href="ressource.html">RESSOURCES</a></li>
    </ul>
    <ul id="hiddenUl">
      <li id="hiddenLi2">Testons ensemble les 1ers acquis</li>
      <li id="hiddenLi3">Atelier pour s'essayer à canvas</li>
      <li id="hiddenLi4">D'autres exemples d'applications par les simploniens</li>
      <li id="hiddenLi5">Plus de documentation, plus de tutos, plus de waouh !</li>
    </ul>
  </header>
  <h1>Bienvenue sur le tutoriel canvas made in Simplon.co !</h1>
  <p>Vous trouverez dans cette section comment initialiser son canvas, comment s'y repérer, et également, les fonctions primaires nécessaires à une bonne utilisation de ce puissant outil.
  <br>À chaque étape, un module de test vous est proposé afin que vous puissiez essayer par vous même votre compréhension ainsi que le rendu des fonctions. Enjoy ! </p>
  <!-- _______________________ -->
  <h3> Initialisation du canvas dans la page HTML</h3>
  <article>
    <div class="text">
      <p>Avant toute chose il est nécessaire de créer un espace pour le canvas grace à la balise "canvas" dans notre HTML, et plus précisément, dans la balise "body", à laquelle on attribue une hauteur et une largeur:</p>
      <br><p>Il nous faut ensuite charger notre canvas ainsi que les différentes variables nécessaires à son exécution:</p>
        <ul>
          <li>La variable feuille correspond à notre canvas, c’est la « feuille » sur laquelle nous allons dessiner.</li>
          <li>La variable context nous permet de définir le context dans lequel nous allons dessiner sur notre feuille: 2d ou 3d. Ici nous travaillerons exclusivement en 2d. Selon le context choisi, canvas aura accès à différentes fonctions et méthodes.</li>
          <li>La variable input est facultative, elle nous permet d’avoir un espace pour écrire nos fonctions qui seront à interpréter par canvas. Elle doit être liée à une balise "input".</li>
        </ul>
        <br><p>Une fois le canvas initié, nous pouvons plonger dans les méthodes de dessin 2d.</p>
  </div>
    <div class="image">
      <img src="Images/declare.png"/>
      <img src="Images/init.png"/>
    </div>
    </article>
  <div class="trait"></div>
  <!-- ________________________________ -->
  <h3> Se repérer dans l'espace canvas</h3>
  <article>
    <div class="text">
      <p>L’espace de dessin de canvas se définit comme un graphique en 2 dimensions ou 2 axes (X et Y), ou encore comme une grille de pixels, quadrillée, dont le point d’origine 0 se situe en haut à gauche et X étant toujours définit en premier lorsque l’on indique des coordonnées. </p>
      <br><p>(exemple: (x = 100, y = 200) donc  x = 100 pixels sur la droite et y = 200 pixels vers le bas)</p>
      <br><p>Passons maintenant aux formes de dessin basiques de canvas.</p>
    </div>
    <div class="image">
      <img src="Images/echelle.png"/>
    </div>
  </article>
  <div class="trait"></div>
  <!-- _________________________ -->
  <p>Il existe plusieurs formes géométriques proposées de bases par canvas, le trait, le rectangle et l’arc de cercle. Elles possèdent chacune leurs propres fonctions, méthodes et paramètres à renseigner et doivent être systématiquement appelées à partir de la variable « context » que nous avons définit au préalable.</p>
  <h3>Les bases du dessins en canvas</h3>
  <article>
    <div class="text">
      <h4>Le rectangle</h4>
      <p>C’est la forme la plus simple d’utilisation. On distingue 2 méthodes: stroke ou fill soit respectivement l’intérieur vide ou l’intérieur plein.</p>
      <br><p> Chaque forme possède ses propres méthodes autour de stroke et fill. Ici nous nous intéresserons principalement à « style » pour donner une couleur à nos traits puis « rect » pour dessiner notre rectangle.</p>
        <ul>
          <li>context.strokeStyle ou context.fillStyle, peuvent s’apparenter à une modification des propriétés CSS de notre rectangle, ici la couleur (NB: par défaut la valeur est « black »),</li>
          <li>context.strokeRect ou context.fillRect, est la fonction qui effectue le tracé,</li>
          <li>le couple (ax, ay) correspond aux coordonnées d’origine du tracé,</li>
          <li>le couple (bx, by) correspond aux dimensions du tracé à partir du point d’origine.</li>
        </ul>
    </div>
    <div class="image">
      <img src="Images/rect.png"/>
      <img src="Images/rect1.png"/>
    </div>
  </article>
  <div class="canvasBox">
    <textarea id="tryRect" name="name" rows="15" cols="40">

      rectVide(0,0,50,50);
      rectPlein(350,0,400,50,"green");

      <!-- version hors fonction, amusez vous ;) -->

      function rect() {
        context2.fillStyle = "pink";
        context2.fillRect(200,150,400,200);
      }

      rect();

    </textarea>
    <button type="button" name="button" onclick="recupRect()">Try it !</button>
    <canvas id="canvas2" height="200" width="400"></canvas>
  </div>
  <!-- _______________________ -->
  <article>
    <div class="text">
      <h4>Le trait</h4>
      <p>Un trait / tracé se déroule en plusieurs étapes: </p>
      <br><p> initialisation, point de départ, point d'arrivée, clôture et affichage du contour et/ou du remplissage.</p>
        <ul>
          <li>context.beginPath() et context.closePath() sont obligatoires dans le cas d’un trait, ils annoncent à canvas que nous démarrons puis arrêtons un tracé.</li>
          <li>context.moveTo(ax,ay) indique le point de départ du trait aux coordonnées (x,y) renseignées en paramètre.</li>
          <li>context.lineTo(bx,by) indique le point d’arrivée du tracé aux coordonnées (x,y) renseignées</li>
          <li>context.stroke() est essentiel pour que le tracé ait lieu: c’est en quelque sorte l’encre nécessaire pour dessiner.</li>
        </ul>
    </div>
    <div class="image">
      <img src="Images/trait.png"/>
      <img src="Images/trait1.png"/>
    </div>
  </article>
  <div class="canvasBox">
    <textarea id="tryTrait" name="name" rows="15" cols="40">

      trait(0, 0, 50, 50,"red");
      trait(0,100,200,100,"green");
      trait(400,0,50,150,"blue");

      <!-- version hors fonction, amusez vous ;) -->

    function trait2() {
      context.strokeStyle = "pink";
      context.lineWidth = 60;
      context.beginPath();
      context.moveTo(340, 150);
      context.lineTo(400, 150);
      context.closePath();
      context.stroke();
    }

    trait2();

    </textarea>
    <button type="button" name="button" onclick="recupTrait()">Try it !</button>
    <canvas id="canvas" height="200" width="400"></canvas>
  </div>
  <p> NB: Au premier passage du Try it, les traits rouge, vert et bleu sont fins, mais si vous appuyez une seconde fois sur Try it, ces derniers s'épaississent comme le "trait" rose.
    <br> Cela est dû au fait que nous modifions context.lineWidth dans la fonction trait2() et que cela affecte l'ensemble du canvas tant que nous ne spécifions pas à nouveau que context.lineWidth = 1.</p>
  <!-- ____________________________ -->
  <article>
    <div class="text">
      <h4>Le cercle et l'arc de cercle</h4>
      <p>Il n’existe pas vraiment de fonction directement prévue pour faire un cercle mais une fonction arc().</p>
      <br><p> Comme pour nos traits, il faut initialiser le début du dessin avec context.beginPath(), néanmoins, il n’est pas nécessaire de clôturer ce dernier avec context.closePath().
les spécificités se situent au niveau des paramètres à renseigner pour notre fonction context.arc():
        <ul>
          <li>le couple (ax,ay) correspond aux coordonnées (x,y) du centre du cercle que nous voulons tracer</li>
          <li>ayon correspond au rayon de notre cercle</li>
          <li>les angles de début et de fin vont nous permettre de tracer de 1/8ième de cercle jusqu’à un cercle complet et sont exprimés en radians (on multiplie une valeur comprise entre 0 et 2 par Math.PI)</li>
          <li>angleDébut définit le point de départ et angleFin, le point final du tracé. Ainsi, un cercle complet aurait pour angleDébut Math.PI*0 (soit 0) et pour angleFin Math.PI*2. Pour un demi cercle, on pourrait également faire, Math.PI*0,5 en début et Math.PI*1,5 en fin.</li>
          <li>sensDuTracé nous permet de choisir le sens du tracé à l’aide d’un booléen. True représentant le sens inverse des aiguilles d’une montre et False le sens des aiguilles d’une montre.</li>
        </ul>
        <br><p>A noter que dans le cas d’un cercle complet, true ou false n’ont pas d’importance. Également, il est possible de réaliser un cercle plein en indiquant à la place des méthodes stroke() et strokeStyle(), fill() et fillStyle()</p>
    </div>
    <div class="image">
      <img src="Images/cercle.png"/>
      <img src="Images/cercle1.png"/>
      <img src="Images/cercle2.png"/>
    </div>
  </article>
  <div class="canvasBox">
    <textarea id="tryCercle" name="name" rows="15" cols="40">

      cerclePlein(100,100,50,"blue");
      cercleVide(200,100,50,"purple");

      <!-- version hors fonction, amusez vous ;) -->

      function cercle() {
        context3.beginPath();
        context3.arc(300, 100, 50, 0, Math.PI*1, false);
        context3.fillStyle = "pink";
        context3.fill();
      }

      cercle();

    </textarea>
    <button type="button" name="button" onclick="recupCercle()">Try it !</button>
    <canvas id="canvas3" height="200" width="400"></canvas>
  </div>
  <div class="trait"></div>
  <!-- ___________________________________________ -->
  <h3>Aller plus loin(vers l'infini et au-delà!)</h3>
  <p>Canvas est capable de gérer plus que de simples tracés de formes, il gère également les images, le texte, des effets comme le dégradé et est capable de modifier son point d’origine 0.</p>
  <article>
    <div class="text">
      <h4>Les images</h4>
      <p>Avant de dessiner une image, il est tout d’abord nécessaire de la récupérer. Une fois celle-ci  chargée par canvas, on pourra alors lui demander de l’afficher sur notre feuille.</p>
        <ul>
          <li>new Image() indique à JavaScript que nous créons un nouvel objet de type image.</li>
          <li>image.src nous permet de récupérer une image à l’aide de son url.</li>
          <li>image.onload correspond à la fonction a effectuer une fois l’image chargée.</li>
          <li>context.drawImage() est la fonction permettant de dessiner ou afficher l’image dans canvas.
Le couple (x, y) fait référence aux coordonnées du coin supérieur gauche où l’on souhaite dessiner l’image.</li>
        </ul>
    </div>
    <div class="image">
      <img src="Images/image.png"/>
      <img src="Images/image1.png"/>
    </div>
  </article>
  <div class="canvasBox">
    <textarea id="tryImage" name="name" rows="15" cols="40">

      dessineImage(0,0, "Images/vache.jpg");

      <!-- version hors fonction, amusez vous ;) -->

      function dessineImage2(ax, ay, lien) {
        var image = new Image();
        image.src = lien;
        image.onload = function() {
          context4.drawImage(this, ax, ay);
          };
      }

      dessineImage2();



    </textarea>
    <button type="button" name="button" onclick="recupImage()">Try it !</button>
    <canvas id="canvas4" height="200" width="400"></canvas>
  </div>
<!-- _____________________________________________ -->
<article>
  <div class="text">
    <h4>Le texte</h4>
    <p>Pour faire du texte avec canvas, il n’est pas nécessaire de tracer soit même ses lettres, trait par trait, lettre par lettre…</p>
    <br><p>Heureusement, canvas a tout prévu et il existe deux fonctions capables de dessiner du texte:</p>
      <ul>
        <li>fillText produira des lettres pleines (dont la couleur sera celle de fillStyle)</li>
        <li>strokeText produira uniquement le contour des lettres (dont la couleur sera celle définie au préalable par strokeStyle.</li>
Le couple (x, y) fait référence aux coordonnées du coin supérieur gauche où l’on souhaite dessiner l’image.</li>
      </ul>
      <br><p>Il existe également plusieurs propriétés (très proches du CSS) permettant de choisir sa police, la taille de police, l’alignement...</p>
      <ul>
        <li>font : police, avec une syntaxe semblable à celle rencontrée en CSS</li>
        <li>textAlign : alignement horizontal</li>
        <li>baseline : ligne de base (alignement vertical)</li>
      </ul>
  </div>
  <div class="image">
    <img src="Images/texte.png"/>
    <img src="Images/texte1.png"/>
    <img src="Images/texte2.png"/>
  </div>
</article>
<div class="canvasBox">
  <textarea id="tryTexte" name="name" rows="15" cols="40">

    texte(200,100, "Hello Simplon !");

    <!-- version hors fonction, amusez vous ;) -->

    function texte2( ax, ay, content, font) {
      context5.font = "20px Arial";
      context5.font = font;
      context5.textAlign = "center";
      context5.fillStyle = "black";
      context5.fillText(content, ax, ay);
    }

    texte2();



  </textarea>
  <button type="button" name="button" onclick="recupTexte()">Try it !</button>
  <canvas id="canvas5" height="200" width="400"></canvas>
</div>
<!-- ________________________________________________________ -->
<article>
  <div class="text">
    <h4>Le dégradé</h4>
    <p>Il est possible de réaliser 2 types de dégradés, en ligne ou en cercle. Nous nous intéresserons principalement au dégradé linéaire dans cette partie.</p>
    <br><p>Pour ce faire, il est essentiel de définir une couleur de départ et une d’arrivée. L’instruction ne fonctionnera pas avec moins de 2 couleurs. Pour cela, nous utilisons la méthode addColorStop(p, couleur), p étant la position de la couleur dans le dégradé. </p>
    <p>A noter que la position se situe entre 0(début) à 1(fin). Notre p devra donc être inclut dans cette tranche.
Il est bien évidemment possible d’ajouter autant de couleur que souhaité.</p>
      <ul>
        <li>Avec createLinearGradient(ax, ay, bx, by) on définit l’origine et la fin du dégradé et donc son axe.
Ainsi (0, 0, 300, 300) donnerait un dégradé en diagonale et (0, 0, 300, 0) donnerait un dégradé horizontal, tout deux, sur la moitié de notre canvas de 600px par 300px.</li>
        <li>On utilise ensuite context.fillStyle = linear pour définir le style des formes pleines(fill) en y affectant le dégradé crée dans les instructions précédentes.</li>
        <li>Enfin, context.fillRect dessine notre rectangle aux couleurs de notre dégradé.</li>
      </ul>
  </div>
  <div class="image">
    <img src="Images/degrade.png"/>
    <img src="Images/degrade1.png"/>
  </div>
</article>
<div class="canvasBox">
  <textarea id="tryDegrade" name="name" rows="15" cols="40">

    degrade("orange","yellow", "red");

    <!-- version hors fonction, amusez vous ;) -->

    function degrade2(color1, color2, color3){
      var linear = context6.createLinearGradient(0,0,400,0);
      linear.addColorStop(0, color1);
      linear.addColorStop(0.5, color2);
      linear.addColorStop(1, color3);
      context6.fillStyle = linear;
      context6.fillRect(0,0,400,200);
    }

    degrade2();



  </textarea>
  <button type="button" name="button" onclick="recupDegrade()">Try it !</button>
  <canvas id="canvas6" height="200" width="400"></canvas>
</div>
<div class="trait"></div>
<!-- _____________________________________________________ -->
<h3>Modifier le point d'origine (0, 0)</h3>
<p>En canvas, il est possible de changer le point d’origine (x = 0 et y = 0 par défaut) à l’aide des fonctions translate() et rotate().<br>Pour ce faire, il est important d’étudier en premier lieu, les fonctions save() et restore().</p>
<article>
  <div class="text">
    <h4>Sauvegarde et restauration du point d'origine</h4>
      <ul>
        <li>La méthode save() a pour intérêt de sauvegarder les styles et le context que nous avons définit dans notre canvas.</li>
        <li>restore() permet ainsi de revenir à la dernière sauvegarde effectuée</li>
      </ul>
      <br><p>Par exemple, si vous décidez de modifier votre point d’origine (0, 0), avec la commande translate(), sans avoir sauvegarder (save()) au préalable, vous devrez réutiliser translate() pour le remettre à l’origine. Cela peut devenir très embêtant, notamment lorsque l’on a effectué de nombreux déplacements et rotations.</p>
      <br><p> Entrons maintenant dans le vif du sujet.</p>
  </div>
  <div class="image">
    <img src="Images/save_restore.png"/>
  </div>
</article>
<!-- ____________________________________________________ -->
<article>
  <div class="text">
    <h4>La méthode translate</h4>
    <p>translate() permet de modifier les coordonnées x et y par défaut de notre canvas. Ainsi, notre point d’origine ne sera plus le point (0,0) mais celui choisi par nos soins.</p>
    <br><p>Rappel: Pour plus de simplicité, n’oublier pas d’utiliser save() et ainsi conserver une sauvegarde de votre canvas d’origine ;).</p>
  </div>
  <div class="image">
    <img src="Images/translate.png"/>
  </div>
</article>
<!-- _________________________________________________ -->
<article>
  <div class="text">
    <h4>La méthode rotate</h4>
    <p>rotate(), quant à elle, permet de modifier l’angle par défaut des axes de notre canvas. L’angle est indiqué par défaut en radiant, mais la conversion est possible avec un simple calcul: (angle * (Math.PI / 180)).</p>
    <p>On utilise donc context.rotate(angle *(Math.PI/180) pour définir nos nouveaux axes de tracé.</p>
    <br><p>Rappel: Pour plus de simplicité, n’oublier pas d’utiliser save() et ainsi conserver une sauvegarde de votre canvas d’origine ;).</p>
  </div>
  <div class="image">
    <img src="Images/rotate.png"/>
  </div>
</article>
<div class="trait"></div>
<p>A présent vous êtes fin prêt pour pratiquer d'avantage sur le canvas !</p>



  <!-- ___________________SCRIPT -->
  <script type="text/javascript" src="tuto.js"></script>
</body>
</html>
